# Hololive Tauri App - ì„¸ë¶€ êµ¬í˜„ ê³„íšì„œ

> **í”„ë¡œì íŠ¸**: í™€ë¡œë¼ì´ë¸Œ ìŠ¤íŠ¸ë¦¼ ì•Œë¦¼ ë°ìŠ¤í¬í†± ì•±
> **ì•„í‚¤í…ì²˜**: Tauri v2 (Rust Backend + React Frontend)
> **ì‘ì„±ì¼**: 2026-01-03

---

## 1. í”„ë¡œì íŠ¸ ê°œìš”

### 1.1 ëª©í‘œ
ê¸°ì¡´ `hololive-kakao-bot-go`ì˜ í•µì‹¬ ê¸°ëŠ¥ë“¤ì„ ì™„ì „ ë…ë¦½í˜• ë°ìŠ¤í¬í†± ì•±ìœ¼ë¡œ ì¬êµ¬í˜„:
- ì„œë²„ ì˜ì¡´ì„± ì—†ì´ ë¡œì»¬ì—ì„œ ë™ì‘
- Holodex API ì§ì ‘ í˜¸ì¶œ
- ë„¤ì´í‹°ë¸Œ OS ì•Œë¦¼
- SQLite ë¡œì»¬ ì €ì¥ì†Œ

### 1.2 ê¸°ëŠ¥ ë²”ìœ„

| ê¸°ëŠ¥ | ì„¤ëª… | ìš°ì„ ìˆœìœ„ |
|:---|:---|:---:|
| ë¼ì´ë¸Œ ìŠ¤íŠ¸ë¦¼ ì¡°íšŒ | í˜„ì¬ ì§„í–‰ ì¤‘ì¸ í™€ë¡œë¼ì´ë¸Œ ë°©ì†¡ ëª©ë¡ | P0 |
| ì˜ˆì • ìŠ¤íŠ¸ë¦¼ ì¡°íšŒ | í–¥í›„ 24ì‹œê°„ ë‚´ ì˜ˆì •ëœ ë°©ì†¡ ëª©ë¡ | P0 |
| ë©¤ë²„ ê²€ìƒ‰ | ì´ë¦„/ë³„ëª…ìœ¼ë¡œ ë©¤ë²„ ê²€ìƒ‰ | P0 |
| ì•ŒëŒ ê´€ë¦¬ | íŠ¹ì • ë©¤ë²„ ë°©ì†¡ ì•Œë¦¼ ì„¤ì •/í•´ì œ | P0 |
| ë„¤ì´í‹°ë¸Œ ì•Œë¦¼ | ë°©ì†¡ ì‹œì‘ Në¶„ ì „ OS ì•Œë¦¼ | P0 |
| ì„¤ì • ê´€ë¦¬ | ì•Œë¦¼ ì‹œê°„, í…Œë§ˆ ë“± ì‚¬ìš©ì ì„¤ì • | P1 |
| ë©¤ë²„ ìƒì„¸ ì •ë³´ | í”„ë¡œí•„, í†µê³„, ìµœê·¼ ë°©ì†¡ | P1 |
| ë‹¤í¬ ëª¨ë“œ | ì‹œìŠ¤í…œ í…Œë§ˆ ì—°ë™ | P2 |

---

## 2. ê¸°ìˆ  ìŠ¤íƒ

### 2.1 Backend (Rust)
```toml
[dependencies]
tauri = { version = "2", features = ["devtools"] }
tauri-plugin-notification = "2"
tauri-plugin-sql = { version = "2", features = ["sqlite"] }
tauri-plugin-store = "2"
reqwest = { version = "0.12", features = ["json", "rustls-tls"] }
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
chrono = { version = "0.4", features = ["serde"] }
thiserror = "2"
tracing = "0.1"
tracing-subscriber = "0.3"
```

### 2.2 Frontend (React)
```json
{
  "dependencies": {
    "react": "^19",
    "react-dom": "^19",
    "@tauri-apps/api": "^2",
    "@tauri-apps/plugin-notification": "^2",
    "@tauri-apps/plugin-sql": "^2",
    "@tanstack/react-query": "^5",
    "framer-motion": "^12",
    "lucide-react": "^0.500",
    "clsx": "^2",
    "tailwind-merge": "^3"
  },
  "devDependencies": {
    "vite": "^7",
    "@vitejs/plugin-react": "^5",
    "tailwindcss": "^4",
    "typescript": "~5.9"
  }
}
```

---

## 3. í”„ë¡œì íŠ¸ êµ¬ì¡°

```
hololive-app/
â”œâ”€â”€ src-tauri/                      # Rust ë°±ì—”ë“œ
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”œâ”€â”€ tauri.conf.json
â”‚   â”œâ”€â”€ capabilities/
â”‚   â”‚   â””â”€â”€ default.json            # ê¶Œí•œ ì„¤ì •
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ main.rs                 # ì§„ì…ì 
â”‚       â”œâ”€â”€ lib.rs                  # Tauri ì„¤ì • & ì»¤ë§¨ë“œ ë“±ë¡
â”‚       â”œâ”€â”€ error.rs                # í†µí•© ì—ëŸ¬ íƒ€ì…
â”‚       â”œâ”€â”€ commands/               # IPC ì»¤ë§¨ë“œ
â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”œâ”€â”€ streams.rs          # ìŠ¤íŠ¸ë¦¼ ì¡°íšŒ
â”‚       â”‚   â”œâ”€â”€ members.rs          # ë©¤ë²„ ì¡°íšŒ/ê²€ìƒ‰
â”‚       â”‚   â”œâ”€â”€ alarms.rs           # ì•ŒëŒ CRUD
â”‚       â”‚   â””â”€â”€ settings.rs         # ì„¤ì • ê´€ë¦¬
â”‚       â”œâ”€â”€ api/                    # ì™¸ë¶€ API í´ë¼ì´ì–¸íŠ¸
â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â””â”€â”€ holodex.rs          # Holodex API (Rate Limit, Cache)
â”‚       â”œâ”€â”€ models/                 # ë°ì´í„° ëª¨ë¸
â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”œâ”€â”€ stream.rs
â”‚       â”‚   â”œâ”€â”€ channel.rs
â”‚       â”‚   â”œâ”€â”€ member.rs
â”‚       â”‚   â””â”€â”€ alarm.rs
â”‚       â”œâ”€â”€ storage/                # ì €ì¥ì†Œ ì¶”ìƒí™”
â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â”œâ”€â”€ database.rs         # SQLite ìŠ¤í‚¤ë§ˆ & ì¿¼ë¦¬
â”‚       â”‚   â””â”€â”€ cache.rs            # ì¸ë©”ëª¨ë¦¬ ìºì‹œ
â”‚       â”œâ”€â”€ scheduler/              # ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…
â”‚       â”‚   â”œâ”€â”€ mod.rs
â”‚       â”‚   â””â”€â”€ polling.rs          # ìŠ¤íŠ¸ë¦¼ í´ë§ & ì•Œë¦¼ íŠ¸ë¦¬ê±°
â”‚       â””â”€â”€ data/                   # ì •ì  ë°ì´í„°
â”‚           â””â”€â”€ members.json        # ì„ë² ë“œëœ ë©¤ë²„ ë°ì´í„°
â”‚
â”œâ”€â”€ src/                            # React í”„ë¡ íŠ¸ì—”ë“œ
â”‚   â”œâ”€â”€ main.tsx
â”‚   â”œâ”€â”€ App.tsx
â”‚   â”œâ”€â”€ index.css                   # TailwindCSS v4 (admin-dashboard ìŠ¤íƒ€ì¼)
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ ui/                     # ê³µí†µ UI ì»´í¬ë„ŒíŠ¸
â”‚   â”‚   â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Card.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Input.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Skeleton.tsx
â”‚   â”‚   â”‚   â””â”€â”€ Badge.tsx
â”‚   â”‚   â”œâ”€â”€ layout/
â”‚   â”‚   â”‚   â”œâ”€â”€ Sidebar.tsx
â”‚   â”‚   â”‚   â””â”€â”€ Header.tsx
â”‚   â”‚   â”œâ”€â”€ streams/
â”‚   â”‚   â”‚   â”œâ”€â”€ StreamCard.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ LiveStreamList.tsx
â”‚   â”‚   â”‚   â””â”€â”€ UpcomingStreamList.tsx
â”‚   â”‚   â”œâ”€â”€ members/
â”‚   â”‚   â”‚   â”œâ”€â”€ MemberCard.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ MemberSearch.tsx
â”‚   â”‚   â”‚   â””â”€â”€ MemberDetail.tsx
â”‚   â”‚   â””â”€â”€ alarms/
â”‚   â”‚       â”œâ”€â”€ AlarmList.tsx
â”‚   â”‚       â””â”€â”€ AlarmToggle.tsx
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ Dashboard.tsx           # ë©”ì¸ (ë¼ì´ë¸Œ + ì˜ˆì •)
â”‚   â”‚   â”œâ”€â”€ Members.tsx             # ë©¤ë²„ ëª©ë¡/ê²€ìƒ‰
â”‚   â”‚   â”œâ”€â”€ Alarms.tsx              # ì•ŒëŒ ê´€ë¦¬
â”‚   â”‚   â””â”€â”€ Settings.tsx            # ì„¤ì •
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ useStreams.ts
â”‚   â”‚   â”œâ”€â”€ useMembers.ts
â”‚   â”‚   â”œâ”€â”€ useAlarms.ts
â”‚   â”‚   â””â”€â”€ useTauriCommand.ts
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ tauri.ts                # invoke ë˜í¼
â”‚   â””â”€â”€ lib/
â”‚       â”œâ”€â”€ utils.ts
â”‚       â””â”€â”€ constants.ts
â”‚
â”œâ”€â”€ index.html
â”œâ”€â”€ vite.config.ts
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ README.md
```

---

## 4. ë°ì´í„° ëª¨ë¸ (Go â†’ Rust í¬íŒ…)

### 4.1 Stream (ë°©ì†¡)
```rust
// src-tauri/src/models/stream.rs

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum StreamStatus {
    Live,
    Upcoming,
    Past,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Stream {
    pub id: String,
    pub title: String,
    pub channel_id: String,
    pub channel_name: String,
    pub status: StreamStatus,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_scheduled: Option<DateTime<Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_actual: Option<DateTime<Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub duration: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thumbnail: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel: Option<Channel>,
}

impl Stream {
    pub fn is_live(&self) -> bool {
        self.status == StreamStatus::Live
    }

    pub fn youtube_url(&self) -> String {
        format!("https://youtube.com/watch?v={}", self.id)
    }

    pub fn minutes_until_start(&self) -> Option<i64> {
        self.start_scheduled.map(|scheduled| {
            let now = Utc::now();
            (scheduled - now).num_minutes().max(0)
        })
    }
}
```

### 4.2 Channel (ì±„ë„)
```rust
// src-tauri/src/models/channel.rs

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Channel {
    pub id: String,
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub english_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub photo: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscriber_count: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub org: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group: Option<String>,
}

impl Channel {
    pub fn display_name(&self) -> &str {
        self.english_name.as_deref().unwrap_or(&self.name)
    }

    pub fn is_hololive(&self) -> bool {
        self.org.as_deref() == Some("Hololive")
    }
}
```

### 4.3 Member (ë©¤ë²„)
```rust
// src-tauri/src/models/member.rs

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Aliases {
    #[serde(default)]
    pub ko: Vec<String>,
    #[serde(default)]
    pub ja: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Member {
    pub id: i32,
    pub channel_id: String,
    pub name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aliases: Option<Aliases>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name_ja: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name_ko: Option<String>,
    #[serde(default)]
    pub is_graduated: bool,
}

impl Member {
    pub fn all_aliases(&self) -> Vec<&str> {
        let mut result = Vec::new();
        if let Some(aliases) = &self.aliases {
            result.extend(aliases.ko.iter().map(String::as_str));
            result.extend(aliases.ja.iter().map(String::as_str));
        }
        result
    }

    pub fn matches_query(&self, query: &str) -> bool {
        let query_lower = query.to_lowercase();
        self.name.to_lowercase().contains(&query_lower)
            || self.name_ko.as_ref().map_or(false, |n| n.to_lowercase().contains(&query_lower))
            || self.name_ja.as_ref().map_or(false, |n| n.to_lowercase().contains(&query_lower))
            || self.all_aliases().iter().any(|a| a.to_lowercase().contains(&query_lower))
    }
}
```

### 4.4 Alarm (ì•ŒëŒ)
```rust
// src-tauri/src/models/alarm.rs

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Alarm {
    pub id: i64,
    pub channel_id: String,
    pub member_name: String,
    pub enabled: bool,
    pub created_at: DateTime<Utc>,
}

impl Alarm {
    pub fn new(channel_id: String, member_name: String) -> Self {
        Self {
            id: 0, // DBì—ì„œ ìë™ ìƒì„±
            channel_id,
            member_name,
            enabled: true,
            created_at: Utc::now(),
        }
    }
}
```

---

## 5. Holodex API í´ë¼ì´ì–¸íŠ¸

### 5.1 í•µì‹¬ ê¸°ëŠ¥ (Goì—ì„œ í¬íŒ…)
```rust
// src-tauri/src/api/holodex.rs

use std::sync::Arc;
use std::time::Duration;
use reqwest::Client;
use tokio::sync::RwLock;
use crate::models::{Stream, Channel};
use crate::error::AppError;

const BASE_URL: &str = "https://holodex.net/api/v2";
const RATE_LIMIT_PER_SECOND: u32 = 10;

pub struct HolodexClient {
    client: Client,
    api_key: String,
    cache: Arc<RwLock<Cache>>,
}

struct Cache {
    live_streams: Option<(Vec<Stream>, std::time::Instant)>,
    upcoming_streams: Option<(Vec<Stream>, std::time::Instant)>,
}

impl HolodexClient {
    pub fn new(api_key: String) -> Self {
        let client = Client::builder()
            .timeout(Duration::from_secs(30))
            .build()
            .expect("Failed to create HTTP client");

        Self {
            client,
            api_key,
            cache: Arc::new(RwLock::new(Cache {
                live_streams: None,
                upcoming_streams: None,
            })),
        }
    }

    /// í˜„ì¬ ë¼ì´ë¸Œ ì¤‘ì¸ í™€ë¡œë¼ì´ë¸Œ ìŠ¤íŠ¸ë¦¼ ì¡°íšŒ
    pub async fn get_live_streams(&self) -> Result<Vec<Stream>, AppError> {
        // ìºì‹œ í™•ì¸ (30ì´ˆ TTL)
        {
            let cache = self.cache.read().await;
            if let Some((streams, cached_at)) = &cache.live_streams {
                if cached_at.elapsed() < Duration::from_secs(30) {
                    return Ok(streams.clone());
                }
            }
        }

        let url = format!("{}/live", BASE_URL);
        let response = self.client
            .get(&url)
            .header("X-APIKEY", &self.api_key)
            .query(&[("org", "Hololive"), ("type", "stream")])
            .send()
            .await?
            .json::<Vec<HolodexStreamRaw>>()
            .await?;

        let streams: Vec<Stream> = response.into_iter()
            .map(|raw| raw.into())
            .collect();

        // ìºì‹œ ì—…ë°ì´íŠ¸
        {
            let mut cache = self.cache.write().await;
            cache.live_streams = Some((streams.clone(), std::time::Instant::now()));
        }

        Ok(streams)
    }

    /// ì˜ˆì •ëœ ìŠ¤íŠ¸ë¦¼ ì¡°íšŒ (hours ì‹œê°„ ì´ë‚´)
    pub async fn get_upcoming_streams(&self, hours: u32) -> Result<Vec<Stream>, AppError> {
        // ìºì‹œ í™•ì¸ (60ì´ˆ TTL)
        {
            let cache = self.cache.read().await;
            if let Some((streams, cached_at)) = &cache.upcoming_streams {
                if cached_at.elapsed() < Duration::from_secs(60) {
                    return Ok(streams.clone());
                }
            }
        }

        let url = format!("{}/live", BASE_URL);
        let max_upcoming = format!("{}", hours * 3600); // ì´ˆ ë‹¨ìœ„

        let response = self.client
            .get(&url)
            .header("X-APIKEY", &self.api_key)
            .query(&[
                ("org", "Hololive"),
                ("status", "upcoming"),
                ("max_upcoming_hours", &hours.to_string()),
            ])
            .send()
            .await?
            .json::<Vec<HolodexStreamRaw>>()
            .await?;

        let streams: Vec<Stream> = response.into_iter()
            .map(|raw| raw.into())
            .collect();

        // ìºì‹œ ì—…ë°ì´íŠ¸
        {
            let mut cache = self.cache.write().await;
            cache.upcoming_streams = Some((streams.clone(), std::time::Instant::now()));
        }

        Ok(streams)
    }
}

/// Holodex API ì‘ë‹µ Raw êµ¬ì¡°ì²´
#[derive(Debug, Deserialize)]
struct HolodexStreamRaw {
    id: String,
    title: String,
    status: String,
    #[serde(rename = "start_scheduled")]
    start_scheduled: Option<String>,
    #[serde(rename = "start_actual")]
    start_actual: Option<String>,
    channel: Option<HolodexChannelRaw>,
}

#[derive(Debug, Deserialize)]
struct HolodexChannelRaw {
    id: String,
    name: String,
    english_name: Option<String>,
    photo: Option<String>,
    org: Option<String>,
}

impl From<HolodexStreamRaw> for Stream {
    fn from(raw: HolodexStreamRaw) -> Self {
        // ë³€í™˜ ë¡œì§...
        todo!()
    }
}
```

---

## 6. SQLite ìŠ¤í‚¤ë§ˆ

```sql
-- src-tauri/migrations/001_init.sql

-- ì•ŒëŒ í…Œì´ë¸”
CREATE TABLE IF NOT EXISTS alarms (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    channel_id TEXT NOT NULL UNIQUE,
    member_name TEXT NOT NULL,
    enabled INTEGER NOT NULL DEFAULT 1,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX idx_alarms_channel ON alarms(channel_id);

-- ì„¤ì • í…Œì´ë¸”
CREATE TABLE IF NOT EXISTS settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- ì•Œë¦¼ íˆìŠ¤í† ë¦¬ (ì¤‘ë³µ ì•Œë¦¼ ë°©ì§€)
CREATE TABLE IF NOT EXISTS notification_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    stream_id TEXT NOT NULL,
    notified_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX idx_notification_stream ON notification_history(stream_id);
```

---

## 7. IPC ì»¤ë§¨ë“œ

### 7.1 ìŠ¤íŠ¸ë¦¼ ì»¤ë§¨ë“œ
```rust
// src-tauri/src/commands/streams.rs

use tauri::State;
use crate::api::HolodexClient;
use crate::models::Stream;
use crate::error::AppError;

#[tauri::command]
pub async fn get_live_streams(
    holodex: State<'_, HolodexClient>,
) -> Result<Vec<Stream>, String> {
    holodex.get_live_streams()
        .await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn get_upcoming_streams(
    holodex: State<'_, HolodexClient>,
    hours: Option<u32>,
) -> Result<Vec<Stream>, String> {
    let hours = hours.unwrap_or(24);
    holodex.get_upcoming_streams(hours)
        .await
        .map_err(|e| e.to_string())
}
```

### 7.2 ì•ŒëŒ ì»¤ë§¨ë“œ
```rust
// src-tauri/src/commands/alarms.rs

use tauri::State;
use crate::storage::Database;
use crate::models::Alarm;

#[tauri::command]
pub async fn get_alarms(db: State<'_, Database>) -> Result<Vec<Alarm>, String> {
    db.get_all_alarms().await.map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn add_alarm(
    db: State<'_, Database>,
    channel_id: String,
    member_name: String,
) -> Result<Alarm, String> {
    db.insert_alarm(channel_id, member_name)
        .await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn remove_alarm(
    db: State<'_, Database>,
    alarm_id: i64,
) -> Result<(), String> {
    db.delete_alarm(alarm_id).await.map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn toggle_alarm(
    db: State<'_, Database>,
    alarm_id: i64,
    enabled: bool,
) -> Result<(), String> {
    db.update_alarm_enabled(alarm_id, enabled)
        .await
        .map_err(|e| e.to_string())
}
```

---

## 8. ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ì¼€ì¤„ëŸ¬

```rust
// src-tauri/src/scheduler/polling.rs

use std::sync::Arc;
use std::time::Duration;
use tauri::{AppHandle, Manager};
use tauri_plugin_notification::NotificationExt;
use tokio::time::interval;
use crate::api::HolodexClient;
use crate::storage::Database;

pub async fn start_polling(
    app: AppHandle,
    holodex: Arc<HolodexClient>,
    db: Arc<Database>,
) {
    let mut interval = interval(Duration::from_secs(60)); // 1ë¶„ë§ˆë‹¤ í´ë§

    loop {
        interval.tick().await;

        if let Err(e) = check_and_notify(&app, &holodex, &db).await {
            tracing::error!("Polling error: {}", e);
        }
    }
}

async fn check_and_notify(
    app: &AppHandle,
    holodex: &HolodexClient,
    db: &Database,
) -> Result<(), Box<dyn std::error::Error>> {
    // 1. í™œì„±í™”ëœ ì•ŒëŒ ì¡°íšŒ
    let alarms = db.get_enabled_alarms().await?;
    if alarms.is_empty() {
        return Ok(());
    }

    let alarm_channels: std::collections::HashSet<_> =
        alarms.iter().map(|a| a.channel_id.as_str()).collect();

    // 2. ë¼ì´ë¸Œ + ì˜ˆì • ìŠ¤íŠ¸ë¦¼ ì¡°íšŒ
    let live_streams = holodex.get_live_streams().await.unwrap_or_default();
    let upcoming_streams = holodex.get_upcoming_streams(1).await.unwrap_or_default(); // 1ì‹œê°„ ì´ë‚´

    // 3. ì•ŒëŒ ëŒ€ìƒ ìŠ¤íŠ¸ë¦¼ í•„í„°ë§
    for stream in live_streams.iter().chain(upcoming_streams.iter()) {
        if !alarm_channels.contains(stream.channel_id.as_str()) {
            continue;
        }

        // 4. ì¤‘ë³µ ì•Œë¦¼ ì²´í¬
        if db.was_notified(&stream.id).await? {
            continue;
        }

        // 5. ë„¤ì´í‹°ë¸Œ ì•Œë¦¼ ë°œì†¡
        let title = if stream.is_live() {
            format!("ğŸ”´ {} ë°©ì†¡ ì‹œì‘!", stream.channel_name)
        } else {
            let mins = stream.minutes_until_start().unwrap_or(0);
            format!("â° {} {}ë¶„ í›„ ë°©ì†¡ ì‹œì‘", stream.channel_name, mins)
        };

        app.notification()
            .builder()
            .title(&title)
            .body(&stream.title)
            .show()?;

        // 6. ì•Œë¦¼ ê¸°ë¡
        db.record_notification(&stream.id).await?;
    }

    Ok(())
}
```

---

## 9. Frontend êµ¬í˜„

### 9.1 Tauri API ë˜í¼
```typescript
// src/api/tauri.ts

import { invoke } from '@tauri-apps/api/core';

export interface Stream {
  id: string;
  title: string;
  channelId: string;
  channelName: string;
  status: 'live' | 'upcoming' | 'past';
  startScheduled?: string;
  thumbnail?: string;
  channel?: Channel;
}

export interface Channel {
  id: string;
  name: string;
  englishName?: string;
  photo?: string;
  subscriberCount?: number;
}

export interface Member {
  id: number;
  channelId: string;
  name: string;
  nameKo?: string;
  nameJa?: string;
  isGraduated: boolean;
}

export interface Alarm {
  id: number;
  channelId: string;
  memberName: string;
  enabled: boolean;
  createdAt: string;
}

// ìŠ¤íŠ¸ë¦¼ API
export const streamApi = {
  getLive: () => invoke<Stream[]>('get_live_streams'),
  getUpcoming: (hours?: number) => invoke<Stream[]>('get_upcoming_streams', { hours }),
};

// ë©¤ë²„ API
export const memberApi = {
  getAll: () => invoke<Member[]>('get_members'),
  search: (query: string) => invoke<Member[]>('search_members', { query }),
};

// ì•ŒëŒ API
export const alarmApi = {
  getAll: () => invoke<Alarm[]>('get_alarms'),
  add: (channelId: string, memberName: string) =>
    invoke<Alarm>('add_alarm', { channelId, memberName }),
  remove: (alarmId: number) => invoke<void>('remove_alarm', { alarmId }),
  toggle: (alarmId: number, enabled: boolean) =>
    invoke<void>('toggle_alarm', { alarmId, enabled }),
};
```

### 9.2 Dashboard í˜ì´ì§€
```tsx
// src/pages/Dashboard.tsx

import { useQuery } from '@tanstack/react-query';
import { streamApi } from '../api/tauri';
import { StreamCard } from '../components/streams/StreamCard';
import { Skeleton } from '../components/ui/Skeleton';

export function Dashboard() {
  const { data: liveStreams, isLoading: liveLoading } = useQuery({
    queryKey: ['streams', 'live'],
    queryFn: streamApi.getLive,
    refetchInterval: 30_000, // 30ì´ˆë§ˆë‹¤ ê°±ì‹ 
  });

  const { data: upcomingStreams, isLoading: upcomingLoading } = useQuery({
    queryKey: ['streams', 'upcoming'],
    queryFn: () => streamApi.getUpcoming(24),
    refetchInterval: 60_000, // 1ë¶„ë§ˆë‹¤ ê°±ì‹ 
  });

  return (
    <div className="space-y-8 p-6">
      {/* ë¼ì´ë¸Œ ìŠ¤íŠ¸ë¦¼ */}
      <section>
        <h2 className="text-xl font-bold mb-4 flex items-center gap-2">
          <span className="w-3 h-3 bg-red-500 rounded-full animate-pulse" />
          ë¼ì´ë¸Œ ì¤‘
        </h2>

        {liveLoading ? (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {[...Array(3)].map((_, i) => (
              <Skeleton key={i} className="h-48 rounded-xl" />
            ))}
          </div>
        ) : liveStreams?.length === 0 ? (
          <p className="text-muted-foreground">í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ë°©ì†¡ì´ ì—†ìŠµë‹ˆë‹¤</p>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {liveStreams?.map((stream) => (
              <StreamCard key={stream.id} stream={stream} />
            ))}
          </div>
        )}
      </section>

      {/* ì˜ˆì • ìŠ¤íŠ¸ë¦¼ */}
      <section>
        <h2 className="text-xl font-bold mb-4">ğŸ“… ì˜ˆì •ëœ ë°©ì†¡ (24ì‹œê°„)</h2>

        {upcomingLoading ? (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {[...Array(6)].map((_, i) => (
              <Skeleton key={i} className="h-48 rounded-xl" />
            ))}
          </div>
        ) : upcomingStreams?.length === 0 ? (
          <p className="text-muted-foreground">ì˜ˆì •ëœ ë°©ì†¡ì´ ì—†ìŠµë‹ˆë‹¤</p>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {upcomingStreams?.map((stream) => (
              <StreamCard key={stream.id} stream={stream} />
            ))}
          </div>
        )}
      </section>
    </div>
  );
}
```

---

## 10. êµ¬í˜„ ì¼ì •

### Phase 1: í”„ë¡œì íŠ¸ ì´ˆê¸°í™” (1ì¼)
- [ ] Tauri v2 í”„ë¡œì íŠ¸ ìƒì„± (React + TypeScript + Vite)
- [ ] í”ŒëŸ¬ê·¸ì¸ ì„¤ì¹˜ (notification, sql, store)
- [ ] TailwindCSS v4 ì„¤ì • (admin-dashboard ìŠ¤íƒ€ì¼ ë³µì‚¬)
- [ ] ê¸°ë³¸ ë ˆì´ì•„ì›ƒ êµ¬ì„±

### Phase 2: Rust ë°±ì—”ë“œ (2-3ì¼)
- [ ] ë°ì´í„° ëª¨ë¸ êµ¬í˜„ (Stream, Channel, Member, Alarm)
- [ ] Holodex API í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„
- [ ] SQLite ìŠ¤í† ë¦¬ì§€ êµ¬í˜„
- [ ] IPC ì»¤ë§¨ë“œ ë“±ë¡

### Phase 3: Frontend UI (2ì¼)
- [ ] UI ì»´í¬ë„ŒíŠ¸ êµ¬í˜„ (Card, Button, Input ë“±)
- [ ] Dashboard í˜ì´ì§€ êµ¬í˜„
- [ ] Members í˜ì´ì§€ êµ¬í˜„
- [ ] Alarms í˜ì´ì§€ êµ¬í˜„
- [ ] Settings í˜ì´ì§€ êµ¬í˜„

### Phase 4: ì•Œë¦¼ ì‹œìŠ¤í…œ (1ì¼)
- [ ] ë°±ê·¸ë¼ìš´ë“œ í´ë§ ìŠ¤ì¼€ì¤„ëŸ¬ êµ¬í˜„
- [ ] ë„¤ì´í‹°ë¸Œ ì•Œë¦¼ ì—°ë™
- [ ] ì¤‘ë³µ ì•Œë¦¼ ë°©ì§€ ë¡œì§

### Phase 5: ë§ˆë¬´ë¦¬ (1ì¼)
- [ ] ì—ëŸ¬ í•¸ë“¤ë§ ê°œì„ 
- [ ] ë¡œë”©/ì—ëŸ¬ ìƒíƒœ UI
- [ ] ì•± ì•„ì´ì½˜ ë° ìŠ¤í”Œë˜ì‹œ ìŠ¤í¬ë¦°
- [ ] ë¹Œë“œ ë° íŒ¨í‚¤ì§• í…ŒìŠ¤íŠ¸

---

## 11. í™˜ê²½ ì„¤ì •

### 11.1 Holodex API í‚¤
```bash
# .env (ê°œë°œìš©)
HOLODEX_API_KEY=your_api_key_here
```

### 11.2 Tauri ì„¤ì •
```json
// src-tauri/tauri.conf.json
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "Hololive Stream Notifier",
  "identifier": "com.kapu.hololive-app",
  "version": "0.1.0",
  "build": {
    "frontendDist": "../dist"
  },
  "app": {
    "windows": [
      {
        "title": "Hololive Stream Notifier",
        "width": 1200,
        "height": 800,
        "minWidth": 800,
        "minHeight": 600
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "active": true,
    "targets": ["deb", "appimage", "msi"],
    "icon": ["icons/icon.png"]
  }
}
```

---

## 12. ì°¸ê³  ìë£Œ

- [Tauri v2 ê³µì‹ ë¬¸ì„œ](https://v2.tauri.app/)
- [Holodex API ë¬¸ì„œ](https://docs.holodex.net//)
- ê¸°ì¡´ Go êµ¬í˜„: `/home/kapu/gemini/llm/hololive-kakao-bot-go/`
- í”„ë¡ íŠ¸ì—”ë“œ ìŠ¤íƒ€ì¼: `/home/kapu/gemini/llm/admin-dashboard/frontend/`
